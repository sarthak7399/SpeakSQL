# ================================================================
# --- Imports ---
# ================================================================
import google.generativeai as genai

# Import modularized functions from your custom modules
from Modules.loadEnvVariables import load_environment_variables
from Modules.loadDatabase import initialize_database
from Modules.loadFewShots import load_few_shot_examples # Assuming you made this a separate module
from Modules.loadEmbeddings import initialize_huggingface_embeddings, setup_vectorstore_and_selector
from Modules.setupPromptTemplate import setup_few_shot_prompt_template # Assuming you made this a separate module
from Modules.loadSQLChain import initialize_sql_database_chain # Assuming you made this a separate module

from langchain_google_genai import ChatGoogleGenerativeAI


# ================================================================
# --- Main Chain Initialization Function ---
# ================================================================
def get_few_shot_sql_chain():
    """
    Initializes and returns a LangChain SQLDatabaseChain configured with few-shot learning
    and a Google Gemini LLM.

    Returns:
        SQLDatabaseChain: An initialized SQLDatabaseChain object ready for queries.
    """
    print("\n--- Setting up Few-Shot SQL Chain ---")

    # Load environment variables
    env_vars = load_environment_variables()
    GOOGLE_API_KEY = env_vars.get('GOOGLE_API_KEY')

    # Ensure GOOGLE_API_KEY is set
    if not GOOGLE_API_KEY:
        print("Error: GOOGLE_API_KEY not found in environment variables. Please set it.")
        exit()

    # Configure Gemini API
    genai.configure(api_key=GOOGLE_API_KEY)
    llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash", temperature=0, google_api_key=GOOGLE_API_KEY)

    # Load database environment variables
    db_user = env_vars.get('db_user')
    db_password = env_vars.get('db_password')
    db_host = env_vars.get('db_host')
    db_port = env_vars.get('db_port')
    db_name = env_vars.get('db_name')

    # Initialize MySQL Database
    # Removed 'wanna_print=False' as it was not part of the original initialize_database signature
    db, database_schema = initialize_database(db_user, db_password, db_host, db_port, db_name)

    # Load few-shot examples
    few_shot_examples = load_few_shot_examples() # Assumes load_few_shot_examples is defined and imported

    # Initialize the embeddings model
    embeddings = initialize_huggingface_embeddings() # Assumes initialize_huggingface_embeddings is defined and imported

    # Setup vector store and example selector
    example_selector = setup_vectorstore_and_selector(few_shot_examples, embeddings, k_examples=2) # Assumes setup_vectorstore_and_selector is defined and imported

    # Setup few-shot prompt
    few_shot_prompt = setup_few_shot_prompt_template(example_selector) # Assumes setup_few_shot_prompt_template is defined and imported

    # Initialize SQLDatabaseChain
    # Set verbose=True to see the intermediate steps of the chain (helpful for debugging)
    sql_chain = initialize_sql_database_chain(llm, db, few_shot_prompt, verbose=False)

    print("--- Few-Shot SQL Chain Setup Complete ---")
    return sql_chain


# ================================================================
# --- Main Execution Block ---
# ================================================================
if __name__ == "__main__":
    # Get the initialized SQL chain
    sql_chain = get_few_shot_sql_chain()

    # Example Query
    q1 = "How many tshirts do we have left for Nike in small size and red colour?"
    print(f"\n--- Querying: '{q1}' ---")
    try:
        # SQLDatabaseChain.invoke() expects a dictionary with a 'query' key
        response1 = sql_chain.invoke({"query": q1})
        print(f"Final Answer for '{q1}':")
        # The output structure depends on the chain's configuration (verbose, return_intermediate_steps, etc.)
        # If 'verbose=True', it often returns a dictionary. If not, it might be just the answer string.
        if isinstance(response1, dict) and 'result' in response1:
            print(response1['result'])
        else:
            print(response1) # Print directly if it's just the string result
    except Exception as e:
        print(f"Error processing query '{q1}': {e}")
        print("This might be due to a quota limit, an invalid query generated by the LLM, or a database issue.")
        print("Please check the error message for more details.")

    print("\n--- End of Query ---")

    # You can add more queries here
    # q2 = "List all products where the quantity is less than 10."
    # print(f"\n--- Querying: '{q2}' ---")
    # try:
    #     response2 = sql_chain.invoke({"query": q2})
    #     print(f"Final Answer for '{q2}':")
    #     if isinstance(response2, dict) and 'result' in response2:
    #         print(response2['result'])
    #     else:
    #         print(response2)
    # except Exception as e:
    #     print(f"Error processing query '{q2}': {e}")
    #     print("Please check the error message for more details.")
    # print("\n--- End of Query ---")